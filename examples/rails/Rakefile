## run `$ rake`

def generate(out_dir, version)
  require 'orthoses'
  require 'orthoses-rails'
  require 'openssl'
  require 'cgi'
  require 'uri'

  Orthoses.logger.level = :error

  Orthoses::Utils.unautoload!

  loader = -> () {
    # require "rails/all"
    # require "rails/app_updater"
    require "active_support/all"
    require "active_record"
    require "active_job"
    require "active_model"
    require "active_storage/engine"
    require "action_dispatch"
    require "action_mailbox"
    require "action_mailer"
    require "action_pack"
    require "action_text"
    require "action_view"

    [
      ActiveSupport,
      ActiveModel,
      ActiveJob,
      ActiveRecord,
      ActiveStorage,
      ActionDispatch,
      ActionMailbox,
      ActionMailer,
      ActionText,
      ActionView,
    ].each do |rails_mod|
      rails_mod.eager_load!
      Orthoses::Utils.each_const_recursive(rails_mod, on_error: -> (e) {
        Orthoses.logger.warn "skip load const by [#{e.root}][#{e.const}](#{e.error.class})#{e.error.message}"
      })
      v = rails_mod.respond_to?(:version) ? rails_mod.version : nil
      puts "loaded #{rails_mod}: v#{v}"
    end
    eval(<<~RUBY)
      module Dummy
        class Application < Rails::Application
          config.load_defaults #{version.to_s}
          config.active_storage.service = :local
        end
      end
    RUBY
    ENV['RAILS_ENV'] = 'development'
    Rails.application.initialize!
    Orthoses::Utils.unautoload!
  }
  Orthoses::Builder.new do
    use Orthoses::CreateFileByName,
      base_dir: "#{out_dir}/#{version}",
      header: "# !!! GENERATED CODE !!!"
    use Orthoses::AvoidRecursiveAncestorError
    use Orthoses::Filter,
      if: -> (name, content) {
        # OMG, both ERB and Erb are exist...
        return false if name.start_with?("Erb")

        # ArgumentError
        return false if name.start_with?("I18n::Tests")

        # FIXME: too hard
        return false if name.include?("::Generators")

        # Ignore known sig
        return false if Orthoses::Utils.rbs_defined_class?(name, collection: true) && content.body.empty?

        true
      }
    use Orthoses::Constant,
      strict: false,
      if: -> (current, const, _val, _rbs) {
        !Orthoses::Utils.rbs_defined_const?("#{current}::#{const}", collection: true)
      },
      on_error: -> (e) {
        Orthoses.logger.warn "[Orthoses::Constant] skip load const by #{e.root}[::#{e.const}] (#{e.error.class}) #{e.error.message}"
      }
    Orthoses::ActiveSupport.each do |middleware, **args|
      use middleware, **args
    end
    use Orthoses::ActiveRecord::QueryMethods
    use Orthoses::ActiveRecord::KnownSig
    use Orthoses::ActiveModel::KnownSig
    use Orthoses::ObjectSpaceAll
    use Orthoses::LoadRBS,
      paths: Dir.glob('patch/**/*.rbs')
    use Orthoses::LoadRBS,
      paths: Dir.glob('known_sig/**/*.rbs')
    # require in method
    use Orthoses::Tap do |store|
      store.delete("DummyERB")
      store.delete("DummyCompiler")
    end
    # see activerecord/lib/active_record/migration/compatibility.rb
    use Orthoses::Tap do |store|
      # TODO: make middleware
      if defined?(ActiveRecord::Migration::Compatibility::V7_0)
        store["ActiveRecord::Migration::Compatibility::V6_1"].header = nil
        store["ActiveRecord::Migration::Compatibility::V7_0"].header = "class ActiveRecord::Migration::Compatibility::V7_0 < ActiveRecord::Migration::Current"
      elsif defined?(ActiveRecord::Migration::Compatibility::V6_1)
        store["ActiveRecord::Migration::Compatibility::V6_0"].header = nil
        store["ActiveRecord::Migration::Compatibility::V6_1"].header = "class ActiveRecord::Migration::Compatibility::V6_1 < ActiveRecord::Migration::Current"
      elsif defined?(ActiveRecord::Migration::Compatibility::V6_0)
        store["ActiveRecord::Migration::Compatibility::V5_2"].header = nil
        store["ActiveRecord::Migration::Compatibility::V6_0"].header = "class ActiveRecord::Migration::Compatibility::V6_0 < ActiveRecord::Migration::Current"
      end
    end
    # class_eval in #each
    # see activerecord/lib/active_record/migration/command_recorder.rb
    use Orthoses::Tap do |store|
      content = store["ActiveRecord::Migration::CommandRecorder"]
      ActiveRecord::Migration::CommandRecorder::ReversibleAndIrreversibleMethods.each do |method|
        content << "def #{method}: (*untyped args) ?{ () -> void } -> untyped"
      end
    end
    # class_eval in #each
    # see activerecord/lib/active_record/migration/command_recorder.rb
    use Orthoses::Tap do |store|
      content = store["ActiveRecord::Migration::CommandRecorder::StraightReversions"]
      {
        execute_block:     :execute_block,
        create_table:      :drop_table,
        create_join_table: :drop_join_table,
        add_column:        :remove_column,
        add_index:         :remove_index,
        add_timestamps:    :remove_timestamps,
        add_reference:     :remove_reference,
        add_foreign_key:   :remove_foreign_key,
        add_check_constraint: :remove_check_constraint,
        enable_extension:  :disable_extension
      }.each do |cmd, inv|
        [[inv, cmd], [cmd, inv]].uniq.each do |method, inverse|
          content << "def invert_#{method}: (untyped args) ?{ () -> void } -> [Symbol, untyped, Proc]"
        end
      end
    end
    # singleton_class.class_eval in included
    use Orthoses::Tap do |store|
      store["ActiveRecord::ModelSchema"].body.tap do |body|
        body.delete("alias _inheritance_column= inheritance_column=")
        body.delete("alias inheritance_column= real_inheritance_column=")
      end
    end
    # alias in included block
    use Orthoses::Tap do |store|
      store["ActiveRecord::ConnectionAdapters::ColumnMethods"].body.tap do |body|
        body.delete("alias blob binary")
        body.delete("alias numeric decimal")
      end
    end
    # > Use async_exec instead of exec_params on pg versions before 1.1
    use Orthoses::Tap do |store|
      store["PG::Connection"].body.clear
    end
    # Entrust to auto super class
    use Orthoses::Tap do |store|
      store.each do |_, content|
        if content.header&.include?(" < Type::")
          content.header.sub!(/ < Type::(.*)/, " < ::ActiveModel::Type::\\1")
        end
        # delegate to auto_header
        if content.header&.start_with?("class Arel")
          content.header = nil
        end
      end
      store["ActionView::Helpers::Tags::CollectionRadioButtons::RadioButtonBuilder"].header = nil
      store["ActionView::Helpers::Tags::CollectionCheckBoxes::CheckBoxBuilder"].header = nil
      store["ActionView::SyntaxErrorInTemplate"].header = nil
      # MigrationProxy cannot resolve name since class alias.
      store["ActiveRecord::NullMigration"].header = nil
    end
    use Orthoses::DelegateClass
    use Orthoses::Attribute
    use Orthoses::Mixin,
      if: -> (base_mod, how, mod) {
        mod != Enumerable # TODO
      }
    use Orthoses::RBSPrototypeRB,
      paths: Dir.glob('src/{railties,action{cable,mailbox,mailer,pack,text,view},active{job,model,record,storage,support}}/{app,lib}/**/*.rb'),
      constant_filter: -> (member) { false },
      mixin_filter: -> (member) { false }
    run loader
  end.call

  # $ cat out/7.0/**/*.rbs | wc
  # 69763  339342 2606899
end

VERSIONS = %w[
  6.0
  6.1
  7.0
]

task :clean do
  FileUtils.rm_rf("out")
  FileUtils.rm_rf("export")
end

namespace :bundle do
  task :update do
    VERSIONS.each do |version|
      sh "BUNDLE_GEMFILE=gemfiles/Gemfile_#{version.tr('.', '_')} bundle update"
    end
  end
end

namespace :generate do
  VERSIONS.each do |version|
    desc "generate version=#{version}"
    task version do
      gemfile = File.expand_path("gemfiles/Gemfile_#{version.tr('.', '_')}")
      sh "BUNDLE_GEMFILE=#{gemfile} bundle install"
      sh "BUNDLE_GEMFILE=#{gemfile} bundle exec rake generate:exec:#{version}"
    end
  end
  namespace :exec do
    VERSIONS.each do |version|
      task version do
        generate("out", version)
      end
    end
  end

  desc "generate all library"
  task :all => VERSIONS
end

load 'tasks/active_job.rake'
load 'tasks/active_model.rake'
load 'tasks/active_record.rake'
load 'tasks/active_storage.rake'
load 'tasks/active_support.rake'

namespace :export do
  desc "export all"
  task :all => ["active_support:all", "active_model:all", "active_job:all", "active_record:all", "active_storage:all"]
  VERSIONS.each do |version|
    desc "export all version=#{version}"
    task "all:#{version}" => ["active_support:#{version}", "active_model:#{version}", "active_job:#{version}", "active_record:#{version}", "active_storage:#{version}"]
  end
end

task default: [
  :clean,
  'generate:all',
  'export:all',
]
