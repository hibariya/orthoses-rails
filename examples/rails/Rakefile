REPO_ROOT = "#{File.dirname(__FILE__)}/src"
$:.unshift("#{REPO_ROOT}/actioncable/lib")
$:.unshift("#{REPO_ROOT}/actionmailbox/lib")
$:.unshift("#{REPO_ROOT}/actionmailer/lib")
$:.unshift("#{REPO_ROOT}/actionpack/lib")
$:.unshift("#{REPO_ROOT}/actiontext/lib")
$:.unshift("#{REPO_ROOT}/actionview/lib")
$:.unshift("#{REPO_ROOT}/activejob/lib")
$:.unshift("#{REPO_ROOT}/activemodel/lib")
$:.unshift("#{REPO_ROOT}/activerecord/lib")
$:.unshift("#{REPO_ROOT}/activestorage/lib")
$:.unshift("#{REPO_ROOT}/activesupport/lib")
$:.unshift("#{REPO_ROOT}/railties/lib")

require 'orthoses'
require 'orthoses-rails'
require 'openssl'
require 'cgi'
require 'uri'

Orthoses.logger.level = :error

Orthoses::Utils.unautoload!

def run_child_process
  pid = fork do
    yield
  end
  Process.wait(pid)
end

def switch_branch(name)
  cd "src" do
    sh "git switch #{name}"
  end
end

def generate(out_dir, version)
  loader = -> () {
    # require "rails/all"
    require "rails/app_updater"
    require "active_support/all"
    require "active_record"
    require "active_job"
    require "active_model"
    require "active_storage"
    require "action_dispatch"
    require "action_mailbox"
    require "action_mailer"
    require "action_pack"
    require "action_text"
    require "action_view"

    [
      ActiveSupport,
      ActiveModel,
      ActiveJob,
      ActiveRecord,
      ActiveStorage,
      ActionDispatch,
      ActionMailbox,
      ActionMailer,
      ActionText,
      ActionView,
    ].each do |rails_mod|
      rails_mod.eager_load!
      Orthoses::Utils.each_const_recursive(rails_mod, on_error: -> (e) {
        Orthoses.logger.warn "skip load const by [#{e.root}][#{e.const}](#{e.error.class})#{e.error.message}"
      })
      v = rails_mod.respond_to?(:version) ? rails_mod.version : nil
      puts "loaded #{rails_mod}: v#{v}"
    end
    Orthoses::Utils.unautoload!
  }
  Orthoses::Builder.new do
    use Orthoses::CreateFileByName,
      base_dir: "#{out_dir}/#{version}",
      header: "# !!! GENERATED CODE !!!"
    use Orthoses::AvoidRecursiveAncestorError
    use Orthoses::Filter,
      if: -> (name, content) {
        # OMG, both ERB and Erb are exist...
        return false if name.start_with?("Erb")

        # ArgumentError
        return false if name.start_with?("I18n::Tests")

        # FIXME: too hard
        return false if name.include?("::Generators")

        # Ignore known sig
        return false if Orthoses::Utils.rbs_defined_class?(name, collection: true) && content.body.empty?

        true
      }
    use Orthoses::Constant,
      strict: false,
      if: -> (current, const, _val, _rbs) {
        !Orthoses::Utils.rbs_defined_const?("#{current}::#{const}", collection: true)
      },
      on_error: -> (e) {
        Orthoses.logger.warn "[Orthoses::Constant] skip load const by #{e.root}[::#{e.const}] (#{e.error.class}) #{e.error.message}"
      }
    Orthoses::ActiveSupport.each do |middleware, **args|
      use middleware, **args
    end
    use Orthoses::ActiveRecord::QueryMethods
    use Orthoses::ActiveRecord::KnownSig
    use Orthoses::ActiveModel::KnownSig
    use Orthoses::ObjectSpaceAll
    use Orthoses::LoadRBS,
      paths: Dir.glob('patch/**/*.rbs')
    use Orthoses::LoadRBS,
      paths: Dir.glob('known_sig/**/*.rbs')
    # require in method
    use Orthoses::Tap do |store|
      store.delete("DummyERB")
      store.delete("DummyCompiler")
    end
    # see activerecord/lib/active_record/migration/compatibility.rb
    use Orthoses::Tap do |store|
      # TODO: make middleware
      if defined?(ActiveRecord::Migration::Compatibility::V7_0)
        store["ActiveRecord::Migration::Compatibility::V6_1"].header = nil
        store["ActiveRecord::Migration::Compatibility::V7_0"].header = "class ActiveRecord::Migration::Compatibility::V7_0 < ActiveRecord::Migration::Current"
      elsif defined?(ActiveRecord::Migration::Compatibility::V6_1)
        store["ActiveRecord::Migration::Compatibility::V6_0"].header = nil
        store["ActiveRecord::Migration::Compatibility::V6_1"].header = "class ActiveRecord::Migration::Compatibility::V6_1 < ActiveRecord::Migration::Current"
      elsif defined?(ActiveRecord::Migration::Compatibility::V6_0)
        store["ActiveRecord::Migration::Compatibility::V5_2"].header = nil
        store["ActiveRecord::Migration::Compatibility::V6_0"].header = "class ActiveRecord::Migration::Compatibility::V6_0 < ActiveRecord::Migration::Current"
      end
    end
    # class_eval in #each
    # see activerecord/lib/active_record/migration/command_recorder.rb
    use Orthoses::Tap do |store|
      content = store["ActiveRecord::Migration::CommandRecorder"]
      ActiveRecord::Migration::CommandRecorder::ReversibleAndIrreversibleMethods.each do |method|
        content << "def #{method}: (*untyped args) ?{ () -> void } -> untyped"
      end
    end
    # class_eval in #each
    # see activerecord/lib/active_record/migration/command_recorder.rb
    use Orthoses::Tap do |store|
      content = store["ActiveRecord::Migration::CommandRecorder::StraightReversions"]
      {
        execute_block:     :execute_block,
        create_table:      :drop_table,
        create_join_table: :drop_join_table,
        add_column:        :remove_column,
        add_index:         :remove_index,
        add_timestamps:    :remove_timestamps,
        add_reference:     :remove_reference,
        add_foreign_key:   :remove_foreign_key,
        add_check_constraint: :remove_check_constraint,
        enable_extension:  :disable_extension
      }.each do |cmd, inv|
        [[inv, cmd], [cmd, inv]].uniq.each do |method, inverse|
          content << "def invert_#{method}: (untyped args) ?{ () -> void } -> [Symbol, untyped, Proc]"
        end
      end
    end
    # singleton_class.class_eval in included
    use Orthoses::Tap do |store|
      store["ActiveRecord::ModelSchema"].body.tap do |body|
        body.delete("alias _inheritance_column= inheritance_column=")
        body.delete("alias inheritance_column= real_inheritance_column=")
      end
    end
    # alias in included block
    use Orthoses::Tap do |store|
      store["ActiveRecord::ConnectionAdapters::ColumnMethods"].body.tap do |body|
        body.delete("alias blob binary")
        body.delete("alias numeric decimal")
      end
    end
    # > Use async_exec instead of exec_params on pg versions before 1.1
    use Orthoses::Tap do |store|
      store["PG::Connection"].body.clear
    end
    # Entrust to auto super class
    use Orthoses::Tap do |store|
      store.each do |_, content|
        if content.header&.include?(" < Type::")
          content.header.sub!(/ < Type::(.*)/, " < ::ActiveModel::Type::\\1")
        end
        # delegate to auto_header
        if content.header&.start_with?("class Arel")
          content.header = nil
        end
      end
      store["ActionView::Helpers::Tags::CollectionRadioButtons::RadioButtonBuilder"].header = nil
      store["ActionView::Helpers::Tags::CollectionCheckBoxes::CheckBoxBuilder"].header = nil
      store["ActionView::SyntaxErrorInTemplate"].header = nil
      # MigrationProxy cannot resolve name since class alias.
      store["ActiveRecord::NullMigration"].header = nil
    end
    use Orthoses::DelegateClass
    use Orthoses::Attribute
    use Orthoses::Mixin,
      if: -> (base_mod, how, mod) {
        mod != Enumerable # TODO
      }
    use Orthoses::RBSPrototypeRB,
      paths: Dir.glob('src/{railties,action{cable,mailbox,mailer,pack,text,view},active{job,model,record,storage,support}}/lib/**/*.rb'),
      constant_filter: -> (member) { false },
      mixin_filter: -> (member) { false }
    run loader
  end.call

  # $ cat out/7.0/**/*.rbs | wc
  # 68367  333370 2555378
end

versions = %w[
  6.0
  6.1
  7.0
]

task :clean do
  FileUtils.rm_rf("out")
  FileUtils.rm_rf("export")
end

namespace :generate do
  versions.each do |version|
    task version do
      switch_branch("#{version.tr('.', '-')}-stable")
      run_child_process { generate("out", version) }
    end
  end

  desc "generate all library"
  task :all => versions
end

namespace :export do
  versions.each do |version|
    task version do |t|
      export = "export/activesupport/#{version}"

      sh "rm -fr #{export}"
      sh "mkdir -p #{export}"

      # minimum
      sh "cp -a out/#{version}/active_support.rbs #{export}"
      sh "cp -a out/#{version}/active_support #{export}"
      sh "rm #{export}/active_support/railtie.rbs"

      # core_ext
      %w[
        array benchmark big_decimal class date date_and_time date_time digest
        enumerable file hash integer kernel load_error marshal module name_error numeric
        object pathname range regexp securerandom string symbol time uri
      ].each do |lib|
        out = "out/#{version}/#{lib}"
        sh "cp -a #{out} #{export}" if File.exist?(out)
        sh "cp -a #{out}.rbs #{export}" if File.exist?("#{out}.rbs")
      end

      Pathname(export).join("EXTERNAL_TODO.rbs").write(<<~RBS)
        module Minitest
          class Test
            def name: () -> untyped
            def assert_raises: () -> untyped
            def refute_empty: () -> untyped
            def refute_equal: () -> untyped
            def refute_in_delta: () -> untyped
            def refute_in_epsilon: () -> untyped
            def refute_includes: () -> untyped
            def refute_instance_of: () -> untyped
            def refute_kind_of: () -> untyped
            def refute_match: () -> untyped
            def refute_nil: () -> untyped
            def refute_operator: () -> untyped
            def refute_predicate: () -> untyped
            def refute_respond_to: () -> untyped
            def refute_same: () -> untyped
          end
        end
        module DRb
          module DRbUndumped
          end
        end
        module Concurrent
          class Map
          end
        end
      RBS

      case version
      when "6.0", "6.1"
        sh "rm -fr #{export}/uri"
      when "7.0"
        # deprecated
        sh "rm -fr #{export}/uri{,.rbs}"
      end

      Pathname(export).join('_scripts').tap(&:mkdir).join('test').write(<<~'RUBY')
        #!/usr/bin/env bash

        # set -eou => Exit command with non-zero status code, Output logs of every command executed, Treat unset variables as an error when substituting.
        set -eou pipefail
        # Internal Field Separator - Linux shell variable
        IFS=$'\n\t'
        # Print shell input lines
        set -v

        # Set RBS_DIR variable to change directory to execute type checks using `steep check`
        RBS_DIR=$(cd $(dirname $0)/..; pwd)
        # Set REPO_DIR variable to validate RBS files added to the corresponding folder
        REPO_DIR=$(cd $(dirname $0)/../../..; pwd)
        # Validate RBS files, using the bundler environment present
        bundle exec rbs --repo=$REPO_DIR \
          -r digest -r benchmark -r time -r monitor -r date -r singleton \
          -r logger -r mutex_m -r pathname -r json \
          -r nokogiri \
          -r activesupport validate --silent

        cd ${RBS_DIR}/_test
        # Run type checks
        bundle exec steep check
      RUBY
      sh "chmod +x #{Pathname(export).join('_scripts').join('test')}"
      Pathname(export).join('_test').tap(&:mkdir).join('Steepfile').write(<<~RUBY)
        D = Steep::Diagnostic

        target :test do
          signature "."
          check "."

          repo_path "../../../"

          library "benchmark"
          library "date"
          library "digest"
          library "json"
          library "logger"
          library "monitor"
          library "mutex_m"
          library "pathname"
          library "singleton"
          library "time"

          library "nokogiri"

          library "activesupport:#{version}"

          configure_code_diagnostics(D::Ruby.all_error)
        end
      RUBY
      Pathname(export).join('_test').join('test.rb').write(<<~'RUBY')
        require 'active_support/all'

        # Test ActiveSupport::NumericWithFormat
        42.to_s
        42.to_s(:phone)
      RUBY

      sh "rbs --collection ../../rbs_collection.yaml -I #{export} validate --silent"
    end
  end

  desc "export all library"
  task :all => versions
end

task default: [
  :clean,
  'generate:all',
  'export:all',
]
